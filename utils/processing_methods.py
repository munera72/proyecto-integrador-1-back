#import matplotlib.pyplot as plt
import numpy as np

#from skimage.io import imread, imshow, imread_collection, concatenate_images

import albumentations as A
from skimage.filters import gaussian


def apply_gaussian_filter(image, sigma=1.0):
    """
    Apply Gaussian filter to an image using scikit-image.

    Args:
    - image (np.ndarray): Input image (can be RGB or grayscale).
    - sigma (float): Standard deviation of the Gaussian filter.
                     Larger values result in stronger blur.

    Returns:
    - blurred_image (np.ndarray): The blurred image.
    """
    # Apply Gaussian filter
    blurred_image = gaussian(image, sigma=sigma)
    blurred_image_uint8 = (blurred_image * 255).astype(np.uint8)
    return blurred_image_uint8

def zeros_arr_generator(size, max_iter=50):
    """
    Created by: Juan Pablo Gomez Lopez & John Jader Caro Sanchez
    Generates a random array of integers of the specified size with values between 0 and 1,
    and ensures that the array contains at least one non-zero element. If no non-zero element
    is found after `max_iter` iterations, the function will return the last generated array.

    Args:
        size (int or tuple of ints): The shape of the array to be generated. Can be an integer
                                      for a 1D array or a tuple for a multi-dimensional array.
        max_iter (int, optional): The maximum number of iterations to attempt generating a valid
                                  array. Defaults to 50.

    Returns:
        numpy.ndarray: A random integer array of shape `size` containing at least one non-zero element.

    Raises:
        ValueError: If no valid array is found within `max_iter` iterations (all arrays generated
                    are full of zeros).
    """
    for i in range(max_iter):
        random_array = np.random.randint(2, size=size)  # Generate a random array with 0s and 1s
        if not np.all(random_array == 0):  # Check if the array has at least one non-zero element
            return random_array

    # If no valid array was found after max_iter attempts, raise an error
    raise ValueError(f"Unable to generate an array with non-zero elements after {max_iter} attempts.")

def augment_image_V2(image: np.ndarray, mask: np.ndarray, N: int):
    """
    Created by: Juan Pablo Gomez Lopez & John Jader Caro Sanchez
    Augments an input image and its corresponding mask using a series of transformations,
    and generates N augmented versions of the image and mask.

    The transformations applied to the image and mask include:
    1. Gaussian noise
    2. Random brightness and contrast adjustments
    3. Random rotation (between -90 and 90 degrees)
    4. Random horizontal flip

    The probability of each transformation being applied is determined by a randomly generated
    array of probabilities, which are generated by the `zeros_arr_generator` function.

    Args:
        image (np.ndarray): The input image to augment. It is assumed to be a numpy array.
        mask (np.ndarray): The corresponding mask for the input image. It should have the same
                            shape as the image.
        N (int): The number of augmented image-mask pairs to generate.

    Returns:
        tuple: A tuple containing two lists:
            - `augment_images` (list): A list of N augmented images.
            - `augment_masks` (list): A list of N augmented masks.

    Raises:
        AssertionError: If the number of transformations in the augmentation pipeline does not
                        match the expected number of transformations (4 in this case).

    Notes:
        - The function uses the `albumentations` library (`A.Compose`) to apply a sequence of
          transformations to both the image and the mask.
        - The probability of each transformation being applied is randomly generated by
          `zeros_arr_generator`, a helper function that returns a list of probabilities.
        - The exact transformations applied may vary for each augmented image-mask pair.
    """
    def build_transform_pipeline():
        """
        Created by: Juan Pablo Gomez Lopez & John Jader Caro Sanchez
        Builds and returns an augmentation pipeline with randomly generated transformation
        probabilities for each of the defined transformations.

        The pipeline includes the following transformations:
        1. Gaussian noise (`A.GaussNoise`)
        2. Random brightness and contrast adjustment (`A.RandomBrightnessContrast`)
        3. Random rotation (`A.Rotate`)
        4. Horizontal flip (`A.HorizontalFlip`)

        Returns:
            A.Compose: The albumentations transformation pipeline with randomly set probabilities.
        """
        arr_len = 4  # Define the number of transformations in the pipeline
        probs = zeros_arr_generator(arr_len)  # Generate random probabilities for each transformation

        # Define the augmentation pipeline using albumentations
        transform = A.Compose([
            A.GaussNoise(p=probs[0]),  # Apply Gaussian noise with a certain probability
            A.RandomBrightnessContrast(p=probs[1]),  # Apply random brightness/contrast change
            A.Rotate(p=probs[2]),  # Apply random rotation with a certain probability
            A.HorizontalFlip(p=probs[3]),  # Apply random horizontal flip
        ])

        # Ensure the number of transformations matches the expected count
        error_msg = "arr_len debe tener la misma cantidad de trasnformaciones "
        assert len(transform.get_dict_with_id()['transforms']) == arr_len, error_msg

        return transform


    augment_images = []  # List to store augmented images
    augment_masks = []  # List to store augmented masks

    # Generate N augmented image-mask pairs
    for i in range(N):
        transform = build_transform_pipeline()  # Build the transformation pipeline
        transform_result = transform(image=image, mask=mask)  # Apply transformations to image and mask
        augment_images.append(transform_result["image"])  # Append the augmented image
        augment_masks.append(transform_result["mask"])  # Append the augmented mask

    # Return the augmented image-mask pairs
    return augment_images, augment_masks

def augmentation_pipeline(imgs: list, masks: list, N: int, filter_callback = None):
    """
    Created by: Juan Pablo Gomez Lopez & John Jader Caro Sanchez

    Applies an augmentation pipeline to a list of images and their corresponding masks.

    This function generates augmented images and masks by applying a specified
    augmentation method to each image-mask pair. It also allows for an optional
    filtering step on the augmented images using a callback function.

    Parameters:
    - imgs (list): A list of input images to be augmented.
    - masks (list): A list of corresponding masks for each input image.
    - N (int): The number of augmentations to generate for each image-mask pair.
    - filter_callback (callable, optional): A callback function that takes an image
      as input and returns a filtered image. If None, a default Gaussian filter
      with sigma=0.7 will be applied.

    Returns:
    - final_images (list): A list containing the original and augmented images
      after filtering.
    - final_masks (list): A list containing the original and augmented masks.

    Example:
    >>> augmented_images, augmented_masks = augmentation_pipeline(images, masks, N=5)

    Notes:
    - The function uses `augment_image` to generate augmentations for each image-mask pair.
    - The filtering is applied to both the original and augmented images before they are returned.
    """

    if filter_callback is None:
        apply_filter = lambda x: apply_gaussian_filter(x, sigma=0.7)
    else:
        apply_filter = filter_callback

    final_images = []
    final_masks = []

    for i, m in zip(imgs, masks):
        # Generate augmented images and masks
        augment_images, augment_masks = augment_image_V2(i, m, N)

        # Concatenate original and augmented images/masks
        concat_imgs = [i] + augment_images
        concat_masks = [m] + augment_masks

        # Apply the specified filter to each concatenated image
        concat_imgs_filtered = list(map(apply_filter, concat_imgs))

        # Append filtered images and original/augmented masks to final lists
        final_images += concat_imgs_filtered  # Append filtered imgs
        final_masks += concat_masks            # Append masks

    return final_images, final_masks


